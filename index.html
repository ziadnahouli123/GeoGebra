<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>MiniGeo Advanced - Interactive Geometry & Function Plotter</title>
<style>
  * {
    box-sizing: border-box;
  }
  body, html {
    margin:0; padding:0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #1e1e2f;
    color: #eee;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  header {
    background: #27293d;
    padding: 0.75em 1em;
    text-align: center;
    font-weight: 700;
    font-size: 1.5rem;
    user-select:none;
    border-bottom: 2px solid #444661;
  }

  main {
    flex: 1;
    display: flex;
    height: 100%;
    overflow: hidden;
  }

  #sidebar {
    width: 320px;
    background: #2a2c43;
    border-right: 2px solid #444661;
    display: flex;
    flex-direction: column;
    padding: 1em 1.5em 0 1.5em;
    overflow-y: auto;
  }
  #sidebar h2 {
    font-size: 1.2rem;
    margin-bottom: 0.75em;
    color: #88c0d0;
    user-select:none;
  }
  label {
    margin-top: 1em;
    font-weight: 600;
    font-size: 1rem;
    display: block;
    user-select:none;
  }
  input[type="text"], input[type="number"] {
    width: 100%;
    padding: 0.4em 0.7em;
    margin-top: 0.25em;
    border-radius: 5px;
    border: none;
    font-size: 1rem;
    font-family: monospace;
  }
  input[type="number"]::-webkit-inner-spin-button,
  input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  button {
    margin-top: 1em;
    background: #88c0d0;
    color: #1e1e2f;
    font-weight: 700;
    border:none;
    padding: 0.6em 1.2em;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.25s ease;
    user-select:none;
  }
  button:hover {
    background: #5a9dbf;
  }
  button:disabled, button[disabled] {
    background: #555f71;
    cursor: not-allowed;
  }

  #canvas-container {
    flex: 1;
    position: relative;
    background: #161624;
    touch-action: none;
  }

  canvas {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    height: 100%;
    width: 100%;
    display: block;
    background-color: #161624;
  }

  #info {
    margin-top: auto;
    font-size: 0.8rem;
    color: #8899aa;
    user-select:none;
    padding-bottom: 1em;
  }

  #functions-legend {
    margin-top: 1em;
    max-height: 130px;
    overflow-y: auto;
    border-top: 1px solid #444661;
    padding-top: 0.5em;
  }
  #functions-legend p {
    margin: 0.25em 0;
    font-family: monospace;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    user-select:none;
  }
  .func-color-box {
    display: inline-block;
    width: 14px;
    height: 14px;
    margin-right: 0.7em;
    border-radius: 3px;
    border: 1.5px solid #2e3440;
  }

  @media (max-width: 480px) {
    #sidebar {
      width: 100%;
      height: 320px;
      border-right: none;
      border-bottom: 2px solid #444661;
      padding-bottom: 0.6em;
      overflow-y: auto;
    }
    main {
      flex-direction: column-reverse;
    }
    #canvas-container {
      height: calc(100% - 320px);
    }
  }
</style>
</head>
<body>
<header>MiniGeo Advanced: Interactive Geometry & Function Plotter</header>
<main>
  <aside id="sidebar" aria-label="Controls">
    <h2>Geometry Tools</h2>
    <button id="add-point-btn" aria-pressed="false" aria-label="Add a movable point">Add Point</button>
    <button id="add-line-btn" aria-pressed="false" aria-label="Add a line between two points">Add Line</button>
    <button id="add-circle-btn" aria-pressed="false" aria-label="Add a circle from two points">Add Circle</button>
    <button id="add-polygon-btn" aria-pressed="false" aria-label="Add a polygon by selecting points">Add Polygon</button>
    <button id="undo-btn" aria-label="Undo last action" disabled>Undo</button>
    <button id="redo-btn" aria-label="Redo last undone action" disabled>Redo</button>
    <button id="clear-geometry-btn" aria-label="Clear all geometry">Clear Geometry</button>
    
    <h2>Function Plotter</h2>
    <label for="function-input">f(x) =</label>
    <input type="text" id="function-input" placeholder="e.g. sin(x), x^2 + 3*x - 5" aria-label="Function input" />
    <button id="plot-func-btn">Plot Function</button>
    <button id="clear-func-btn">Clear Functions</button>
    <div id="functions-legend" aria-label="Function legend"></div>

    <h2>Grid & View</h2>
    <label><input type="checkbox" id="grid-toggle" checked /> Show Grid</label>
    <label for="grid-size">Grid size (units):</label>
    <input type="number" id="grid-size" value="1" min="0.1" step="0.1" />
    <button id="reset-view-btn" aria-label="Reset zoom and pan">Reset View</button>

    <h2>Selected Point Coordinates</h2>
    <label for="coord-x">X:</label>
    <input type="number" id="coord-x" step="0.01" />
    <label for="coord-y">Y:</label>
    <input type="number" id="coord-y" step="0.01" />
    <button id="update-point-btn">Update Point</button>

    <div id="info" aria-live="polite" aria-atomic="true" style="margin-top:10px;">
      <p>Use the tools above to construct and manipulate geometry and plot functions.</p>
      <p>Drag points to move them. Use mouse wheel or pinch to zoom. Drag background to pan.</p>
      <p id="selection-info" style="color:#bf616a; font-weight:600;"></p>
    </div>
  </aside>
  <section id="canvas-container" role="img" aria-label="Interactive geometry and graphing canvas">
    <canvas id="geo-canvas" tabindex="0"></canvas>
  </section>
</main>
<script>
(() => {
  const canvas = document.getElementById('geo-canvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = canvas.clientWidth * dpr;
    canvas.height = canvas.clientHeight * dpr;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr,dpr);
  }
  window.addEventListener('resize', () => {
    resizeCanvas();
    draw();
  });
  resizeCanvas();

  let points = [];
  let lines = [];
  let circles = [];
  let polygons = [];
  let functions = [];

  let mode = null;
  let draggingPointIndex = -1;
  let selectedPointsForLine = [];
  let selectedPointsForCircle = [];
  let selectedPointsForPolygon = [];

  let pan = {x:0, y:0};
  let zoom = 15; // Set initial zoom lower to show more area and allow easier placement
  let draggingCanvas = false;
  let dragStart = null;

  const history = [];
  let historyIndex = -1;

  const btnAddPoint = document.getElementById('add-point-btn');
  const btnAddLine = document.getElementById('add-line-btn');
  const btnAddCircle = document.getElementById('add-circle-btn');
  const btnAddPolygon = document.getElementById('add-polygon-btn');
  const btnUndo = document.getElementById('undo-btn');
  const btnRedo = document.getElementById('redo-btn');
  const btnClearGeometry = document.getElementById('clear-geometry-btn');
  const inpFunction = document.getElementById('function-input');
  const btnPlotFunc = document.getElementById('plot-func-btn');
  const btnClearFunc = document.getElementById('clear-func-btn');
  const functionsLegend = document.getElementById('functions-legend');
  const gridToggle = document.getElementById('grid-toggle');
  const gridSizeInput = document.getElementById('grid-size');
  const resetViewBtn = document.getElementById('reset-view-btn');
  const coordXInput = document.getElementById('coord-x');
  const coordYInput = document.getElementById('coord-y');
  const updatePointBtn = document.getElementById('update-point-btn');
  const selectionInfo = document.getElementById('selection-info');

  let selectedPointIndex = -1;

  function saveHistory() {
    const snapshot = JSON.stringify({points,lines,circles,polygons,functions});
    if(historyIndex < history.length-1) history.splice(historyIndex+1);
    history.push(snapshot);
    historyIndex++;
    updateUndoRedoButtons();
  }
  function loadHistory(index) {
    if(index < 0 || index >= history.length) return;
    const snapshot = JSON.parse(history[index]);
    points = snapshot.points;
    lines = snapshot.lines;
    circles = snapshot.circles;
    polygons = snapshot.polygons;
    functions = snapshot.functions;
    mode = null;
    selectedPointsForLine = [];
    selectedPointsForCircle = [];
    selectedPointsForPolygon = [];
    selectedPointIndex = -1;
    updateSelectionInfo('');
    updateCoordInputs();
    draw();
    updateUndoRedoButtons();
  }
  function updateUndoRedoButtons(){
    btnUndo.disabled = historyIndex <= 0;
    btnRedo.disabled = historyIndex >= history.length -1;
  }

  function toCanvasX(x) { return canvas.width/2/ (window.devicePixelRatio || 1) + (x + pan.x)*zoom; }
  function toCanvasY(y) { return canvas.height/2/ (window.devicePixelRatio || 1) - (y + pan.y)*zoom; }
  function toMathX(cx) { return (cx - canvas.width/2/ (window.devicePixelRatio || 1))/zoom - pan.x; }
  function toMathY(cy) { return (canvas.height/2/ (window.devicePixelRatio || 1) - cy)/zoom - pan.y; }

  function drawGrid(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    if(!gridToggle.checked) return;

    const step = parseFloat(gridSizeInput.value) || 1;
    const gridColor = '#3b4252';
    const labelColor = '#4c566a';
    ctx.lineWidth = 1;

    const left = toMathX(0);
    const right = toMathX(canvas.width/ (window.devicePixelRatio || 1));
    const bottom = toMathY(canvas.height/ (window.devicePixelRatio || 1));
    const top = toMathY(0);

    for(let x = Math.floor(left/step)*step; x <= right; x += step){
      const cx = toCanvasX(x);
      ctx.beginPath();
      ctx.strokeStyle = gridColor;
      ctx.moveTo(cx, 0);
      ctx.lineTo(cx, canvas.height/ (window.devicePixelRatio || 1));
      ctx.stroke();
      if(Math.abs(x) > 1e-6){
        ctx.fillStyle = labelColor;
        ctx.font = '10px Segoe UI, monospace';
        ctx.textAlign = 'center';
        ctx.fillText(x.toFixed(2), cx, canvas.height/2/ (window.devicePixelRatio || 1) + 12);
      }
    }

    for(let y = Math.floor(bottom/step)*step; y <= top; y += step){
      const cy = toCanvasY(y);
      ctx.beginPath();
      ctx.strokeStyle = gridColor;
      ctx.moveTo(0, cy);
      ctx.lineTo(canvas.width/ (window.devicePixelRatio || 1), cy);
      ctx.stroke();
      if(Math.abs(y) > 1e-6){
        ctx.fillStyle = labelColor;
        ctx.font = '10px Segoe UI, monospace';
        ctx.textAlign = 'right';
        ctx.fillText(y.toFixed(2), canvas.width/2/ (window.devicePixelRatio || 1) - 6, cy + 3);
      }
    }
    const originX = toCanvasX(0);
    const originY = toCanvasY(0);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#d8dee9';
    ctx.beginPath();
    ctx.moveTo(originX, 0);
    ctx.lineTo(originX, canvas.height/ (window.devicePixelRatio || 1));
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, originY);
    ctx.lineTo(canvas.width/ (window.devicePixelRatio || 1), originY);
    ctx.stroke();
  }

  function drawPoint(pt, highlight = false){
    const x = toCanvasX(pt.x);
    const y = toCanvasY(pt.y);
    ctx.beginPath();
    ctx.fillStyle = highlight ? '#bf616a' : '#88c0d0';
    ctx.strokeStyle = '#2e3440';
    ctx.lineWidth = 2;
    ctx.arc(x,y,7,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();

    ctx.font = '12px Segoe UI, monospace';
    ctx.fillStyle = '#d8dee9';
    ctx.textAlign = 'center';
    ctx.fillText(`(${pt.x.toFixed(2)}, ${pt.y.toFixed(2)})`, x, y - 12);

    if(pt.label){
      ctx.font = 'bold 14px Segoe UI, sans-serif';
      ctx.fillStyle = '#d8dee9';
      ctx.fillText(pt.label, x + 10, y - 10);
    }
  }

  function drawLine(line){
    if(line.p1Index < 0 || line.p2Index < 0) return;
    const p1 = points[line.p1Index];
    const p2 = points[line.p2Index];
    if(!p1 || !p2) return;
    const x1 = toCanvasX(p1.x);
    const y1 = toCanvasY(p1.y);
    const x2 = toCanvasX(p2.x);
    const y2 = toCanvasY(p2.y);

    ctx.beginPath();
    ctx.strokeStyle = '#81a1c1';
    ctx.lineWidth = 2;
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();

    // Draw equation
    const eqText = getLineEquation(p1, p2);
    if(eqText){
      const mx = (x1 + x2)/2;
      const my = (y1 + y2)/2;
      ctx.font = '13px Segoe UI, monospace';
      ctx.fillStyle = '#81a1c1';
      ctx.fillText(eqText, mx + 10, my);
    }
  }

  function drawCircle(circle){
    if(circle.centerIndex < 0 || circle.pointOnCircIndex < 0) return;
    const center = points[circle.centerIndex];
    const pointOnCirc = points[circle.pointOnCircIndex];
    if(!center || !pointOnCirc) return;
    const cx = toCanvasX(center.x);
    const cy = toCanvasY(center.y);
    const radius = Math.sqrt(Math.pow(toCanvasX(pointOnCirc.x) - cx,2)+Math.pow(toCanvasY(pointOnCirc.y) - cy,2));
    ctx.beginPath();
    ctx.strokeStyle = '#bf616a';
    ctx.lineWidth = 2;
    ctx.arc(cx, cy, radius, 0, 2*Math.PI);
    ctx.stroke();

    const eqText = getCircleEquation(center, pointOnCirc);
    if(eqText){
      ctx.font = '13px Segoe UI, monospace';
      ctx.fillStyle = '#bf616a';
      ctx.fillText(eqText, cx + radius + 5, cy);
    }
  }

  function getLineEquation(p1, p2){
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    if(Math.abs(dx) < 1e-10){
      return `x = ${p1.x.toFixed(2)}`;
    }
    const m = dy/dx;
    let b = p1.y - m*p1.x;
    if(Math.abs(b) < 1e-6) b = 0;
    return `y = ${m.toFixed(2)}x ${b>=0 ? '+' : '-'} ${Math.abs(b).toFixed(2)}`;
  }

  function getCircleEquation(center, pointOnCirc){
    const r = Math.sqrt((pointOnCirc.x - center.x)**2 + (pointOnCirc.y - center.y)**2);
    return `(x - ${center.x.toFixed(2)})² + (y - ${center.y.toFixed(2)})² = ${r.toFixed(2)}²`;
  }

  function drawPolygon(polygon){
    const pts = polygon.pointIndices.map(i => points[i]).filter(Boolean);
    if(pts.length < 2) return;

    ctx.beginPath();
    ctx.strokeStyle = '#d08770';
    ctx.lineWidth = 2;
    pts.forEach((pt,i)=>{
      const cx = toCanvasX(pt.x);
      const cy = toCanvasY(pt.y);
      if(i===0) ctx.moveTo(cx, cy);
      else ctx.lineTo(cx, cy);
    });
    if(pts.length>2){
      const first = pts[0];
      ctx.lineTo(toCanvasX(first.x), toCanvasY(first.y));
    }
    ctx.stroke();
    // Area label
    const area = polygonArea(pts);
    if(area != null){
      const centroid = polygonCentroid(pts);
      const cx = toCanvasX(centroid.x);
      const cy = toCanvasY(centroid.y);
      ctx.font = '13px Segoe UI, monospace';
      ctx.fillStyle = '#d08770';
      ctx.fillText('Area: '+area.toFixed(2), cx + 5, cy);
    }
  }
  function polygonArea(points){
    if(points.length<3) return null;
    let area=0;
    for(let i=0;i<points.length;i++){
      let j=(i+1)%points.length;
      area += points[i].x*points[j].y - points[j].x*points[i].y;
    }
    return Math.abs(area)/2;
  }
  function polygonCentroid(points){
    let cx=0,cy=0,area=0;
    for(let i=0;i<points.length;i++){
      let j=(i+1)%points.length;
      const f = points[i].x*points[j].y - points[j].x*points[i].y;
      cx += (points[i].x + points[j].x) * f;
      cy += (points[i].y + points[j].y) * f;
      area += f;
    }
    area*=0.5;
    cx/=(6*area);
    cy/=(6*area);
    return {x: cx, y: cy};
  }

  function drawFunctions(){
    for(let i=0; i<functions.length;i++){
      const fnObj=functions[i];
      drawFunction(fnObj.fn, fnObj.color);
    }
  }
  function drawFunction(fn,color='#a3be8c'){
    ctx.beginPath();
    ctx.lineWidth=2;
    ctx.strokeStyle=color;
    const stepPx=2;
    let first=true;
    for(let px=0; px<=canvas.width/ (window.devicePixelRatio || 1); px+= stepPx){
      const x=toMathX(px);
      let y;
      try{
        y=fn(x);
        if(typeof y !== 'number' || isNaN(y) || !isFinite(y)){
          first=true;
          continue;
        }
      } catch{
        first=true;
        continue;
      }
      const py=toCanvasY(y);
      if(first){
        ctx.moveTo(px,py);
        first=false;
      } else{
        ctx.lineTo(px, py);
      }
    }
    ctx.stroke();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    drawGrid();
    drawFunctions();
    polygons.forEach(drawPolygon);
    circles.forEach(drawCircle);
    lines.forEach(drawLine);
    points.forEach((pt,i)=>{
      const highlight = (
        mode === 'line' && selectedPointsForLine.includes(i) ||
        mode === 'circle' && selectedPointsForCircle.includes(i) ||
        mode === 'polygon' && selectedPointsForPolygon.includes(i) ||
        i === selectedPointIndex
      );
      drawPoint(pt, highlight);
    });
  }

  function findPointNearCanvas(x,y){
    const radius=14;
    for(let i=0; i<points.length;i++){
      const ptC={x: toCanvasX(points[i].x), y: toCanvasY(points[i].y)};
      const distSq=(ptC.x-x)**2+(ptC.y-y)**2;
      if(distSq<=radius*radius) return i;
    }
    return -1;
  }

  // Interaction Handlers
  function onPointerDown(e){
    e.preventDefault();
    const rect=canvas.getBoundingClientRect();
    const cx=(e.clientX || e.touches?.[0]?.clientX)-rect.left;
    const cy=(e.clientY || e.touches?.[0]?.clientY)-rect.top;

    // Support for touch with multiple touches
    if(e.pointerType === 'touch' && e.touches?.length > 1){
      draggingCanvas=true;
      dragStart={x:e.clientX, y:e.clientY, panX:pan.x, panY:pan.y};
      return;
    }

    // Middle mouse button or touch
    if(e.button === 1){
      draggingCanvas=true;
      dragStart={x:e.clientX, y:e.clientY, panX:pan.x, panY:pan.y};
      return;
    }

    if(mode === 'point'){
      points.push({x: toMathX(cx), y: toMathY(cy), label: `P${points.length+1}`});
      saveHistory();
      mode=null;
      updateModeButtons();
      updateSelectionInfo('');
      selectPoint(-1);
      draw();
      return;
    }
    if(mode === 'line'){
      const idx=findPointNearCanvas(cx,cy);
      if(idx !==-1 && !selectedPointsForLine.includes(idx)){
        selectedPointsForLine.push(idx);
        updateSelectionInfo(`Selected points for line: ${selectedPointsForLine.length}/2`);
        if(selectedPointsForLine.length===2){
          lines.push({p1Index:selectedPointsForLine[0], p2Index:selectedPointsForLine[1]});
          selectedPointsForLine=[];
          saveHistory();
          mode=null;
          updateModeButtons();
          updateSelectionInfo('Line added');
        }
        draw();
      }
      return;
    }
    if(mode === 'circle'){
      const idx=findPointNearCanvas(cx,cy);
      if(idx !== -1 && !selectedPointsForCircle.includes(idx)){
        selectedPointsForCircle.push(idx);
        updateSelectionInfo(`Selected points for circle: ${selectedPointsForCircle.length}/2`);
        if(selectedPointsForCircle.length===2){
          circles.push({centerIndex:selectedPointsForCircle[0], pointOnCircIndex:selectedPointsForCircle[1]});
          selectedPointsForCircle=[];
          saveHistory();
          mode=null;
          updateModeButtons();
          updateSelectionInfo('Circle added');
        }
        draw();
      }
      return;
    }
    if(mode === 'polygon'){
      const idx=findPointNearCanvas(cx,cy);
      if(idx !== -1 && !selectedPointsForPolygon.includes(idx)){
        selectedPointsForPolygon.push(idx);
        updateSelectionInfo(`Selected points for polygon: ${selectedPointsForPolygon.length}`);
        draw();
      }
      return;
    }

    let idx=findPointNearCanvas(cx,cy);
    if(idx !== -1){
      draggingPointIndex=idx;
      selectPoint(idx);
    } else {
      draggingCanvas=true;
      dragStart={x:e.clientX, y:e.clientY, panX:pan.x, panY:pan.y};
      selectPoint(-1);
    }
  }

  function onPointerMove(e){
    if(draggingPointIndex === -1 && !draggingCanvas) return;
    e.preventDefault();
    if(draggingCanvas){
      const dx=e.clientX - dragStart.x;
      const dy=e.clientY - dragStart.y;
      pan.x=dragStart.panX + dx/zoom;
      pan.y=dragStart.panY - dy/zoom;
      draw();
      return;
    }
    const rect=canvas.getBoundingClientRect();
    const cx=(e.clientX || e.touches?.[0]?.clientX) - rect.left;
    const cy=(e.clientY || e.touches?.[0]?.clientY) - rect.top;
    const mx=toMathX(cx);
    const my=toMathY(cy);
    points[draggingPointIndex].x=mx;
    points[draggingPointIndex].y=my;
    updateCoordInputs();
    saveHistory();
    draw();
  }

  function onPointerUp(e){
    draggingPointIndex = -1;
    draggingCanvas = false;
  }

  function onWheel(e){
    e.preventDefault();
    const rect=canvas.getBoundingClientRect();
    const cx=e.clientX - rect.left;
    const cy=e.clientY - rect.top;
    const oldZoom=zoom;
    if(e.deltaY < 0) zoom *= 1.1;
    else zoom /= 1.1;
    zoom = Math.min(Math.max(zoom, 5), 300);

    const mathXBefore = toMathX(cx);
    const mathYBefore = toMathY(cy);
    const mathXAfter = (cx - canvas.width/2/ (window.devicePixelRatio || 1))/zoom - pan.x;
    const mathYAfter = (canvas.height/2/ (window.devicePixelRatio || 1) - cy)/zoom - pan.y;
    pan.x += mathXBefore - mathXAfter;
    pan.y += mathYBefore - mathYAfter;

    draw();
  }

  function selectPoint(i){
    selectedPointIndex = i;
    if(i === -1){
      coordXInput.value = '';
      coordYInput.value = '';
      updateSelectionInfo('');
    } else {
      const p = points[i];
      coordXInput.value = p.x.toFixed(3);
      coordYInput.value = p.y.toFixed(3);
      updateSelectionInfo(`Selected point ${p.label || (i+1)}`);
    }
  }

  function updateCoordInputs(){
    if(selectedPointIndex === -1) return;
    const p = points[selectedPointIndex];
    coordXInput.value = p.x.toFixed(3);
    coordYInput.value = p.y.toFixed(3);
  }

  function parseFunction(expr) {
    const validChars = /^[0-9xX+\-*/^()., \t\n\rabsincostanqlepgr]+$/i;
    if (!validChars.test(expr)) throw new Error('Invalid characters in function expression.');
    let jsExpr = expr.toLowerCase().replace(/\^/g, '**');
    ['sin','cos','tan','log','exp','sqrt','abs'].forEach(fn=>{
      const re = new RegExp('\\b'+fn+'\\b', 'g');
      jsExpr = jsExpr.replace(re, `Math.${fn}`);
    });
    jsExpr = jsExpr.replace(/\bln\b/g, 'Math.log');
    return new Function('x', `return ${jsExpr};`);
  }

  function updateFunctionLegend(){
    functionsLegend.innerHTML = '';
    if(functions.length === 0) return;
    functions.forEach(({expr,color}, i) => {
      const p = document.createElement('p');
      p.innerHTML = `<span class="func-color-box" style="background:${color}"></span>f${i+1}(x) = ${expr}`;
      functionsLegend.appendChild(p);
    });
  }

  btnAddPoint.addEventListener('click', () => {
    mode = (mode === 'point') ? null : 'point';
    selectedPointsForLine = [];
    selectedPointsForCircle = [];
    selectedPointsForPolygon = [];
    updateModeButtons();
    updateSelectionInfo(mode === 'point' ? 'Click to add a point' : '');
  });

  btnAddLine.addEventListener('click', () => {
    mode = (mode === 'line') ? null : 'line';
    selectedPointsForLine = [];
    selectedPointsForCircle = [];
    selectedPointsForPolygon = [];
    updateModeButtons();
    updateSelectionInfo(mode === 'line' ? 'Select two points for the line by clicking them' : '');
  });

  btnAddCircle.addEventListener('click', () => {
    mode = (mode === 'circle') ? null : 'circle';
    selectedPointsForCircle = [];
    selectedPointsForLine = [];
    selectedPointsForPolygon = [];
    updateModeButtons();
    updateSelectionInfo(mode === 'circle' ? 'Select two points for the circle by clicking them' : '');
  });

  btnAddPolygon.addEventListener('click', () => {
    if(mode === 'polygon' && selectedPointsForPolygon.length >=3){
      polygons.push({pointIndices: [...selectedPointsForPolygon]});
      selectedPointsForPolygon = [];
      saveHistory();
      updateSelectionInfo('Polygon added');
      mode = null;
      updateModeButtons();
      draw();
      return;
    }
    mode = (mode === 'polygon') ? null : 'polygon';
    selectedPointsForPolygon = [];
    selectedPointsForLine = [];
    selectedPointsForCircle = [];
    updateModeButtons();
    updateSelectionInfo(mode === 'polygon' ? 'Select points for polygon by clicking. Click "Add Polygon" again to finish.' : '');
  });

  btnUndo.addEventListener('click', () => {
    if(historyIndex > 0){
      historyIndex--;
      loadHistory(historyIndex);
    }
  });

  btnRedo.addEventListener('click', () => {
    if(historyIndex < history.length -1){
      historyIndex++;
      loadHistory(historyIndex);
    }
  });

  btnClearGeometry.addEventListener('click', () => {
    points = [];
    lines = [];
    circles = [];
    polygons = [];
    selectedPointsForLine = [];
    selectedPointsForCircle = [];
    selectedPointsForPolygon = [];
    mode = null;
    selectPoint(-1);
    updateModeButtons();
    updateSelectionInfo('Geometry cleared');
    saveHistory();
    draw();
  });

  btnPlotFunc.addEventListener('click', () => {
    const expr = inpFunction.value.trim();
    if(!expr.length){
      alert('Please enter a function expression.');
      return;
    }
    try{
      const fn = parseFunction(expr);
      const color = `hsl(${Math.floor(Math.random()*360)}, 70%, 70%)`;
      functions.push({expr, fn, color});
      updateFunctionLegend();
      inpFunction.value = '';
      saveHistory();
      draw();
    }catch(e){
      alert('Invalid function expression: ' + e.message);
    }
  });

  btnClearFunc.addEventListener('click', () => {
    functions = [];
    updateFunctionLegend();
    saveHistory();
    draw();
  });

  updatePointBtn.addEventListener('click', () => {
    if(selectedPointIndex === -1) return;
    const x = parseFloat(coordXInput.value);
    const y = parseFloat(coordYInput.value);
    if(isNaN(x) || isNaN(y)) {
      alert('Invalid coordinate values');
      return;
    }
    points[selectedPointIndex].x = x;
    points[selectedPointIndex].y = y;
    saveHistory();
    draw();
  });

  resetViewBtn.addEventListener('click', () => {
    pan = {x:0, y:0};
    zoom = 15; // Reset zoom to the lowered initial zoom
    draw();
  });

  gridToggle.addEventListener('change', draw);
  gridSizeInput.addEventListener('input', draw);

  canvas.addEventListener('pointerdown', onPointerDown);
  canvas.addEventListener('pointermove', onPointerMove);
  canvas.addEventListener('pointerup', onPointerUp);
  canvas.addEventListener('pointercancel', onPointerUp);
  canvas.addEventListener('wheel', onWheel, {passive:false});

  function updateModeButtons(){
    btnAddPoint.setAttribute('aria-pressed', mode==='point'?'true':'false');
    btnAddLine.setAttribute('aria-pressed', mode==='line'?'true':'false');
    btnAddCircle.setAttribute('aria-pressed', mode==='circle'?'true':'false');
    btnAddPolygon.setAttribute('aria-pressed', mode==='polygon'?'true':'false');
  }

  function updateSelectionInfo(text){
    selectionInfo.textContent = text;
  }

  function updateCoordInputs(){
    if(selectedPointIndex === -1){
      coordXInput.value = '';
      coordYInput.value = '';
      return;
    }
    const p = points[selectedPointIndex];
    coordXInput.value = p.x.toFixed(3);
    coordYInput.value = p.y.toFixed(3);
  }

  saveHistory();
  updateModeButtons();
  draw();
})();
</script>
</body>
</html>

